# アセットリファレンスガイド

**WaterQuestVRプロジェクト - 使用アセットの技術リファレンス**

このドキュメントは、プロジェクトで使用しているアセット（Obi Fluid、Meta Quest SDK）の技術的な知識と使い方をまとめたリファレンスです。

---

## 目次

- [1. Obi Fluid実装ガイド](#1-obi-fluid実装ガイド)
- [2. Meta Quest HandGrab実装ガイド](#2-meta-quest-handgrab実装ガイド)
- [3. パフォーマンス最適化](#3-パフォーマンス最適化)
- [4. リファレンスリンク](#4-リファレンスリンク)

---

# 1. Obi Fluid実装ガイド

## 1.1 コアコンポーネント

### ObiSolver
- **役割**: パーティクルベースの物理シミュレーションエンジン
- **機能**:
  - リアルタイム流体シミュレーション
  - 双方向リジッドボディ相互作用
  - GPU (Compute) / CPU (Burst) バックエンド対応

```csharp
// 必須設定
ObiSolver solver = GetComponent<ObiSolver>();
solver.substeps = 4;              // シミュレーション精度
solver.maxParticleContacts = 6;   // パーティクルあたりの最大接触数
```

### ObiCollider / ObiCollider2D
- **役割**: Unity Colliderをパーティクルシステムに認識させる
- **必須**: 通常のUnity Colliderだけでは不十分

**サポートされるコライダー**:
- ✅ SphereCollider
- ✅ BoxCollider
- ✅ CapsuleCollider
- ✅ **MeshCollider** (凹型対応)
- ✅ TerrainCollider
- ✅ CharacterController

```csharp
GameObject colliderObject = /* コライダーオブジェクト */;
colliderObject.AddComponent<MeshCollider>();
colliderObject.AddComponent<ObiCollider>();
```

### ObiRigidbody
- **役割**: リジッドボディとパーティクルの双方向物理相互作用
- **自動追加**: ObiColliderが親にRigidbodyを検出すると自動で追加

```csharp
// 設定例
ObiRigidbody obiRb = GetComponent<ObiRigidbody>();
obiRb.kinematicForParticles = false; // パーティクルから力を受ける
```

## 1.2 コリジョン検出とMeshCollider

### MeshColliderの完全サポート

**✅ Meshに沿った正確な当たり判定**

Obiは**TriangleMeshShape**として実装:
- 実際の頂点・三角形データを使用
- BIH (Bounding Interval Hierarchy) で効率的な衝突検出
- **凹型メッシュ対応**（通常のUnity物理では制限あり）

```csharp
// MeshColliderの設定
MeshCollider meshCollider = gameObject.AddComponent<MeshCollider>();
meshCollider.sharedMesh = GetComponent<MeshFilter>().sharedMesh;
meshCollider.convex = false;  // 凹型でもOK！
```

### ObiColliderの重要プロパティ

```csharp
ObiCollider obiCollider = gameObject.GetComponent<ObiCollider>();

// 内側で衝突を検出（受け皿など）
obiCollider.Inverted = true;  // ★重要★

// 衝突範囲の調整
obiCollider.Thickness = 0.01f;

// 物理マテリアル
obiCollider.CollisionMaterial = myCollisionMaterial;
```

#### 受け皿に必須の設定
```csharp
// ボウル、カップなどの受け皿
obiCollider.Inverted = true;  // 内側の衝突を有効化
```

### コリジョンイベント

```csharp
public class CollisionHandler : MonoBehaviour
{
    private ObiSolver solver;

    void OnEnable()
    {
        solver = GetComponent<ObiSolver>();
        solver.OnCollision += Solver_OnCollision;
    }

    void OnDisable()
    {
        solver.OnCollision -= Solver_OnCollision;
    }

    void Solver_OnCollision(object sender, ObiNativeContactList contacts)
    {
        var colliderWorld = ObiColliderWorld.GetInstance();

        for (int i = 0; i < contacts.count; ++i)
        {
            var contact = contacts[i];

            // 接触距離のチェック
            if (contact.distance < 0.01f)
            {
                // コライダー情報の取得
                var collider = colliderWorld.colliderHandles[contact.bodyB].owner;

                // パーティクルインデックス
                int particleIndex = solver.simplices[contact.bodyA];

                // 処理...
            }
        }
    }
}
```

### ObiCollisionMaterial

```csharp
var material = ScriptableObject.CreateInstance<ObiCollisionMaterial>();
material.dynamicFriction = 0.3f;   // 動摩擦
material.staticFriction = 0.4f;    // 静摩擦
material.stickiness = 0.1f;        // 粘着性
material.stickDistance = 0.01f;    // 粘着距離
```

## 1.3 エミッター設定

### ライフスパン（Lifespan）について

#### 定義
- **ライフスパンは生成されたエフェクト（パーティクル）のライフタイム（寿命）を表す**
- 単位: 秒（seconds）
- 個々のパーティクルが存在し続ける時間を制御する
- エミッター自体が止まる時間ではない

#### 動作
- パーティクルが生成されると、`lifespan`の値が設定される
- 時間経過とともに`lifespan`が減算される
- `lifespan <= 0`になると、パーティクルは無効化され、プールに戻る（再利用可能）

### エフェクトの生成量について

#### エフェクトがどれだけ生成されるかは以下に依存する：

1. **BlueprintのCapacity（容量）**
   - `ObiFluidEmitterBlueprint`アセットの`Capacity`パラメータ
   - このエミッターが使用できる最大パーティクル数
   - デフォルト: 1000
   - パーティクルプールのサイズを決定

2. **Speed（エミッション速度）**
   - `ObiEmitter`コンポーネントの`Speed`パラメータ
   - 単位: メートル/秒（m/s）
   - エミッション速度が速いほど、より多くのパーティクルが生成される
   - `Speed = 0`にするとエミッションが停止する

#### 計算式
```
生成されるパーティクル数 ≈ Speed × 時間 × エミッションポイント数
```

ただし、**Capacityの上限を超えることはできない**

### パフォーマンスに関する注意

#### Capacityを大きすぎる値に設定すると：
- **メモリ使用量が増加する**
- **CPU負荷が高くなる**
- **フレームレートが低下する可能性がある**

#### 推奨設定
- **短時間のテスト**: Capacity = 1000〜5000
- **通常の使用**: Capacity = 5000〜10000
- **長時間の連続エミッション**: Capacity = 10000〜20000
- **最大値**: Capacity = 50000（それ以上はパフォーマンスに深刻な影響）

#### 最適化のヒント
- 必要最小限のCapacityに設定する
- `Speed`を調整して、必要な量のパーティクルを生成する
- `Lifespan`を適切に設定して、不要なパーティクルを早期にプールに戻す

## 1.4 トラブルシューティング

### 水が受け皿をすり抜ける

**原因**: `Inverted`が設定されていない

**解決策**:
```csharp
ObiCollider obiCollider = bowl.GetComponent<ObiCollider>();
obiCollider.Inverted = true;  // これを設定
```

### 水のパフォーマンスが悪い

**対策**:
1. MeshColliderの三角形数を減らす
2. `solver.substeps`を下げる (3-4推奨)
3. パーティクル数を制限（Quest向け: 最大500個に制限）
4. `maxParticleContacts`を減らす

---

# 2. Meta Quest HandGrab実装ガイド

## 2.1 HandGrab システム概要

**階層構造**:
```
GrabbableObject (親)
├─ Rigidbody ★必須★
├─ Collider ★必須★
├─ PointableElement (自動追加)
├─ HandGrabInteractable
├─ DistanceHandGrabInteractable
└─ [BuildingBlock] HandGrabInstallationRoutine (子オブジェクト)
```

## 2.2 必須コンポーネント

### Rigidbody
```csharp
Rigidbody rb = gameObject.AddComponent<Rigidbody>();
rb.mass = 1.0f;
rb.useGravity = true;
rb.isKinematic = false; // 掴んでいない時
```

### PointableElement
```csharp
// HandGrabInteractableが自動的に参照
PointableElement pointable = gameObject.AddComponent<PointableElement>();
```

### HandGrabInteractable
```csharp
HandGrabInteractable grabInteractable = gameObject.AddComponent<HandGrabInteractable>();
grabInteractable.Rigidbody = rb;
grabInteractable.PointableElement = pointable;
grabInteractable.InjectRigidbody(rb);
grabInteractable.InjectPointableElement(pointable);
```

## 2.3 BuildingBlock の使い方

**❌ 間違った使い方**:
```
掴めるオブジェクトに直接HandGrabInstallationRoutineをアタッチ
```

**✅ 正しい使い方**:
```
1. Window > Meta > BuildingBlocks を開く
2. "Hand Grab Interaction" を選択
3. 掴みたいオブジェクトにドラッグ＆ドロップ
4. 自動的に子オブジェクトとして配置される
5. 親オブジェクトのコンポーネントを自動参照
```

## 2.4 HandGrabInteractable 設定例

```csharp
// インスペクター設定（Unityファイル内の実例）
_interactorFilters: []
_maxInteractors: -1
_maxSelectingInteractors: -1
_pointableElement: {fileID: 481507807}  // 親から参照
_rigidbody: {fileID: 481507806}          // 親から参照
_kinematicWhileSelected: 1               // 掴んでいる間はKinematic
_throwWhenUnselected: 1                  // 離した時に投げる
```

## 2.5 DistanceHandGrabInteractable

遠距離から掴む機能:

```csharp
DistanceHandGrabInteractable distanceGrab =
    gameObject.AddComponent<DistanceHandGrabInteractable>();

distanceGrab.Rigidbody = rb;
distanceGrab.PointableElement = pointable;

// スコアリング設定（掴みやすさの調整）
distanceGrab.ScoringModifier.PositionRotationWeight = 0.5f;
```

## 2.6 トラブルシューティング

### 掴めない

**チェックリスト**:
- [ ] Rigidbodyがアタッチされているか
- [ ] Colliderがアタッチされているか
- [ ] HandGrabInteractableが正しく設定されているか
- [ ] PointableElementが参照されているか

## 2.7 クイックリファレンス

### 受け皿セットアップ (3ステップ)
```bash
1. MeshCollider追加 (convex=false)
2. ObiCollider追加 (Inverted=true)
3. BuildingBlock追加 (Hand Grab Interaction)
```

### 必須コンポーネントチェックリスト

**水を受ける受け皿**:
- ✅ MeshCollider
- ✅ ObiCollider (Inverted=true)
- ✅ Rigidbody
- ✅ HandGrabInteractable (BuildingBlock経由)

**水を注ぐ器具**:
- ✅ ObiEmitter
- ✅ Rigidbody
- ✅ Collider
- ✅ HandGrabInteractable (BuildingBlock経由)

---

# 3. パフォーマンス最適化

## 3.1 Quest 向け最適化戦略

1. **描画負荷削減**
   - Obi Fluidのパーティクル数: 最大500個（Quest向け推奨）
   - テクスチャ解像度: 1024x1024以下
   - ポリゴン数: シーン全体で50,000以下

2. **物理演算最適化**
   - Fixed Timestep: 0.02 (50Hz)
   - Collision Matrix設定（不要な衝突判定を無効化）
   - ObiSolver設定:
     ```csharp
     solver.substeps = 3;                    // 精度とパフォーマンスのバランス
     solver.maxParticleContacts = 4;         // 接触数を制限
     solver.maxParticleNeighbors = 64;       // 近傍パーティクル数
     solver.maxStepsPerFrame = 1;            // フレームあたりの最大ステップ数
     ```

3. **スクリプト最適化**
   - Update()の使用を最小限に
   - イベント駆動型（パラメータ変更時のみ処理）
   - オブジェクトプール（パーティクル再利用）

4. **Obi設定最適化**
   ```csharp
   // 描画負荷軽減
   ObiFluidRenderer renderer = GetComponent<ObiFluidRenderer>();
   renderer.particleRendering = false;     // 必要に応じて無効化

   // MeshColliderの三角形数を削減
   // Blenderなどで低ポリゴン版を作成
   ```

---

# 4. リファレンスリンク

### Obi
- [公式ドキュメント](http://obi.virtualmethodstudio.com/manual/6.3/index.html)
- [API Reference](http://obi.virtualmethodstudio.com/api/index.html)

### Meta Quest
- [BuildingBlocks](https://developer.oculus.com/documentation/unity/bb-overview/)
- [Interaction SDK](https://developer.oculus.com/documentation/unity/unity-isdk-interaction-sdk-overview/)
- [HandGrab Documentation](https://developer.oculus.com/documentation/unity/unity-isdk-hand-grab/)

---

**最終更新**: 2025-11-26
