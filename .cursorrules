# WaterQuestVRプロジェクト - 開発規約書

このファイルは、Cursor IDEがプロジェクトの構造と規約を理解するための参照ドキュメントです。

## ファイルの目的と制約

**本ファイルはAIへの開発指示専用です。以下を厳守してください：**

1. **記載可能**: コーディング規約、開発ルール、Git管理規則、命名規則、プロジェクト運営方針等のAIへの指示
2. **記載禁止**: アプリケーション固有の仕様、設定方法、API詳細、実装のヒント、技術的解説
3. **更新時の原則**: AIがコードを書く際に必要なルール・規約のみを記載
4. **仕様の参照先**: アプリ固有の詳細は`README.md`や`Documentation/`フォルダを参照

## コーディング規約

### 命名規則
- **クラス名**: PascalCase（例: `GameManager`, `WaterContainer`）
- **メソッド名**: PascalCase（例: `RecordDrawWater`, `FillWater`）
- **変数名**: camelCase（例: `isFull`, `waterQuality`）
- **定数**: UPPER_SNAKE_CASE（例: `SAFE_QUALITY_THRESHOLD`, `MAX_CAPACITY`）
- **インターフェース**: `I`プレフィックス（例: `IWaterReceiver`）

### 必須ルール
1. **名前空間の使用禁止**
   - すべてのクラスはグローバルスコープに配置
   - using文でnamespaceを参照しない（System等の標準ライブラリは除く）
   - 既存のnamespace宣言は削除する

2. **ドキュメント作成の制限**
   - 新しいMarkdownドキュメント（.md）を作成しない
   - ユーザーが明示的に要求した場合のみドキュメントを作成
   - 実装の説明はコード内のコメントで十分
   - 既存のドキュメントへの追記は可能

3. **Meta Quest/VR対応の制限**
   - Meta Quest（Androidビルド）のみをサポート（他のプラットフォームは一切対応しない）
   - VR固有の制約を考慮した実装（パフォーマンス最適化、フレームレート維持等）
   - Meta XR SDKのネイティブAPIを優先使用（OVRCameraRig, OVRHand, OVRInput）
   - OpenXRはサブ扱い（メインではない）
   - VR環境でのみ実行されるコードは`#if UNITY_ANDROID && !UNITY_EDITOR`で囲む
   - エディタ実行時の分岐は`#if UNITY_EDITOR`で制御
   - Quest以外のコードはコメントアウトする（削除ではなく、将来の復元に備える）

4. **メモリ管理の最適化**
   - Quest環境でのメモリリークに注意（特にObi Fluidパーティクル、テクスチャ、音声データ）
   - 不要なオブジェクトは明示的に破棄（Destroy）
   - 定期的なリソースクリーンアップを実装
   - 大量のオブジェクト生成を避ける（Obi Fluidのパーティクル数は最大500個に制限）
   - コルーチンの適切な停止と破棄
   - Update()の使用を最小限に（イベント駆動型を優先）

### コード品質ルール
1. **Pure C#実装の優先**: ビジネスロジックは可能な限りMonoBehaviourに依存しないPure C#で実装
2. **依存性注入パターン**: 少数のMonoBehaviourから統合的に依存性を注入
3. **インターフェース分離**: すべてのサービスはインターフェースを定義
4. **コンストラクタインジェクション**: 設定やサービスはコンストラクタで注入

5. **Find系メソッドの使用禁止**
   - GameObject.Find、FindObjectOfType等の検索系メソッドは使用しない
   - MonoBehaviourの場合: インスペクターでの直接参照設定を必須とする
   - Pure C#の場合: コンストラクタまたはメソッドパラメータでの注入を必須とする
   - 例外: システム初期化時の一回限りの検索のみ許可（要コメント明記）

6. **エラーハンドリング**: try-catchとログ出力を徹底
7. **非同期処理**: コルーチンまたはUniTaskを使用した適切な処理（VR環境でのパフォーマンスを考慮）

8. **コード整形ルール**
   - #region/#endregionディレクティブは使用しない
   - コードの構造化はクラス分割やメソッド分割で行う
   - 既存の#region/#endregionは削除する

9. **文字制限**
   - 絵文字を使用しない（コメント、文字列、変数名等）
   - ユーザーが明示的に要求した場合のみ例外とする
   - 既存コードに含まれる絵文字は削除する

10. **ログ出力の最適化**
    - 重要なイベント（初期化、エラー、状態変更）のみログ出力
    - デバッグ用の詳細ログは条件付きコンパイル（#if UNITY_EDITOR）で囲む
    - ループ内でのログ出力は避ける
    - ログメッセージは簡潔に
    - 一時的なデバッグログは作業完了後に削除

### フォルダ・ファイル管理
- **番号プレフィックス**: 重要度に応じて番号プレフィックスで整理（00-99）
- **機能別グループ化**: 関連機能をフォルダで分類
- **Legacyコード**: 旧コードは`99 Legacy`に配置
- **APIキーの管理**: 絶対にコミットしない（.gitignoreで除外）

### リファクタリング時の削除ルール
- 使用されなくなったファイル（.cs、.meta含む）は完全削除
- 不要になったプロパティ、メソッド、クラスを削除
- 古いインターフェース実装を削除
- 参照されていない設定項目を削除
- 未使用のusing文を削除
- 段階的移行は避け、完全に置き換える
- 削除前にgrep検索で参照がないことを確認
- .csファイル削除時は対応する.metaファイルも削除

## Git管理・ブランチ戦略

### ブランチ運用
1. **develop**: 全ての開発作業はこのブランチで実施
2. **main**: 動作確認済みのコードのみマージ
3. **archive/**: 過去バージョンのアーカイブ用
4. **feature/**: 大規模な機能開発用（オプション）

### コミットルール
1. **作業完了時の必須手順**:
   ```bash
   git add .
   git commit -m "適切なコミットメッセージ"
   git push origin develop
   ```

2. **コミットメッセージ形式**:
   ```
   <type>: <description>
   ```

   **タイプ一覧**:
   - `feat`: 新機能追加
   - `fix`: バグ修正
   - `refactor`: リファクタリング
   - `docs`: ドキュメント更新
   - `style`: コードフォーマット
   - `test`: テスト追加・修正
   - `chore`: ビルド・設定変更

3. **プッシュタイミング**: 作業セッション終了時は必ずプッシュ

### コメント・ドキュメント規約
- **日本語コメント**: コメントは日本語で記述
- **HeaderAttribute**: Unity Inspectorで設定をグループ化
- **TooltipAttribute**: 設定項目に説明を追加
- **XMLドキュメント**: パブリックメンバーには適切な説明を追加

## プロジェクト運営方針

### 変更履歴管理

#### 変更履歴CSVファイルの管理
- **ファイル名**: `変更履歴.csv`（プロジェクトルートに配置）
- **目的**: 問題発生時に履歴を遡って原因を追求するため
- **記録タイミング**: コード変更をコミットする前に必ず記録
- **記録内容**: 日付、日時、変更概要、変更詳細の4カラム

#### CSV記録の必須項目
1. **日付**: YYYY-MM-DD形式（例: 2025-11-17）
2. **日時**: HH:MM:SS形式（例: 12:00:36）
3. **変更概要**: 変更の種類を簡潔に（例: "Phase 1: BedrockRAGStream.jslib作成"）
4. **変更詳細**: 変更内容の詳細な説明
   - どのファイルを変更したか
   - 何を追加/削除/変更したか
   - 既存機能への影響
   - 問題が発覚した場合に原因を特定できる程度の詳細さ

#### 変更履歴記録の重要性
- **問題発覚時の原因追求**: 既に実装できていた機能が、新しい実装によって壊れた場合に履歴を遡って原因を特定
- **ロールバック判断**: どの時点まで戻せば問題が解決するかを判断
- **段階的実装の管理**: 複数の機能を段階的に実装する際の進捗管理

#### 変更履歴記録の例
```
日付,日時,変更概要,変更詳細
2025-11-26,12:00:36,Phase 1: WaterContainer実装,水器具システムの基底クラスWaterContainer.csを作成。2値管理（isFull）を実装、傾き判定機能を追加、FillWater/EmptyWaterメソッドを実装。Bucket.csとCup.csを作成し、それぞれ容量80と5を設定。Obi Fluidエフェクトとの連携を実装。
```

### 開発フロー

#### AI開発プロセス

#### 2段階開発プロセスの原則
すべての開発作業は、**提案段階**と**実装段階**の2段階に分けて実施すること。

#### 段階1: 提案段階（必須）
実装を開始する前に、必ず以下を提示してユーザーの承認を得ること：

1. **現状分析**
   - 現在の実装状況の説明
   - 関連する既存コードの特定
   - 既存機能への影響範囲の評価

2. **実装計画**
   - 変更対象ファイルのリスト
   - 実装手順の詳細（段階的な場合は各段階の説明）
   - 技術的なアプローチの説明

3. **複数の選択肢の提示**
   - 少なくとも2つ以上の実装方法を提示
   - 各選択肢のメリット・デメリット
   - 推奨案とその理由

4. **リスク評価**
   - 既存機能への影響リスク
   - 実装の複雑さ
   - 想定される問題点と対策

**承認前の禁止事項**:
- コードの変更・追加・削除は一切行わない
- ファイルの読み取りと調査のみ実施
- ユーザーが明示的に「実装して」または「承認」と指示するまで待機

#### 段階2: 実装段階（承認後）
ユーザーから承認を得た後にのみ実装を開始すること：

1. **承認された選択肢に基づく実装**
   - 提案段階で承認された方法で実装
   - 提案内容から大きく逸脱する場合は再度提案

2. **段階的な実装**
   - 大きな変更は小さな単位に分割
   - 各段階で動作確認を実施
   - 問題が発生した場合は即座に停止し、ユーザーに報告

3. **変更履歴の記録**
   - 実装完了後、変更履歴CSVに記録
   - 実装内容と提案内容の差分があれば記載

#### 例外処理
以下の場合は提案段階を省略して直接実装可能：
- ユーザーが「すぐに実装して」と明示的に指示した場合
- 既存のバグ修正で影響範囲が限定的な場合（1ファイル、10行以下の変更）
- ドキュメントの誤字脱字の修正
- コードフォーマットのみの変更

ただし、例外適用時も実装前に簡潔な説明を提示すること。

#### 実装前の確認事項
1. **既存機能への影響確認**: 変更が既存機能に影響を与えないか確認
2. **依存関係の確認**: 変更が他のコンポーネントに影響を与えないか確認
3. **テスト計画**: 変更後の動作確認方法を計画

#### 実装時の注意事項
1. **段階的な実装**: 大きな変更は小さな単位に分割して実装
2. **既存コードの保護**: 既存の動作しているコードを壊さないよう注意
3. **変更履歴の記録**: 各変更をCSVに記録

#### 実装後の検証手順
1. **動作確認**: 変更した機能が正常に動作するか確認
2. **既存機能の確認**: 既存機能が壊れていないか確認
3. **変更履歴の更新**: CSVに変更内容を記録
4. **コミット**: Gitにコミット（コミット前にCSV更新を確認）

#### 問題発生時の対応フロー
1. **問題の特定**: どの機能が壊れたか、いつから壊れたかを特定
2. **変更履歴の確認**: CSVを確認して、問題が発生した時点を特定
3. **ロールバック判断**: どの時点まで戻せば問題が解決するかを判断
4. **修正実装**: 問題を修正し、再度段階的に実装

### 既存機能保護の原則
- **AができていてBを実装しようとしたが、Aができなくなってしまった場合**:
  1. AができていてBが実装できていない状態に戻す
  2. 別の方法でBを実装する
  3. 変更履歴CSVに問題と対応を記録

## Meta Quest/VR固有の考慮事項
- パフォーマンス最適化（フレームレート維持、60fps以上を目標）
- メモリ管理の最適化（Questの制限されたメモリを考慮）
- VRインタラクション（ハンドトラッキング、コントローラ操作）
- モーションシックネス対策（低レイテンシ、安定したフレームレート）

### Quest向けパフォーマンス最適化の重要事項（必読）

#### 描画負荷削減
1. **Obi Fluidのパーティクル数制限**: 最大500個に制限
   - パーティクル数はインスペクターで設定可能にする
   - 必要に応じて動的に調整（シーン内の水器具数に応じて）

2. **テクスチャ解像度**: 1024x1024以下に制限
   - 大きなテクスチャは圧縮設定を適切に設定
   - テクスチャストリーミングを有効化

3. **ポリゴン数**: シーン全体で50,000以下を目標
   - LOD（Level of Detail）を適切に設定
   - Occlusion Cullingを有効化

#### 物理演算最適化
1. **Fixed Timestep**: 0.02 (50Hz) に設定
   - デフォルト値のままで問題ないが、必要に応じて調整

2. **Collision Matrix設定**: 不要な衝突判定を無効化
   - 水器具と地面、水器具と水器具など、必要な衝突のみ有効化

3. **Obi Solverの最適化**:
   - パーティクル数は最小限に
   - サブステップ数を適切に設定（デフォルト値で問題ない）

#### スクリプト最適化
1. **Update()の使用を最小限に**:
   ```csharp
   // 誤: 毎フレーム処理
   void Update() {
       CheckWaterLevel();
   }

   // 正: イベント駆動型
   void OnWaterFilled() {
       CheckWaterLevel();
   }
   ```

2. **イベント駆動型の実装**: パラメータ変更時のみ処理
   - 水が満タンになった時、空になった時など、イベントで通知

3. **オブジェクトプール**: パーティクルやエフェクトの再利用
   - Obi Fluidのパーティクルは自動的に管理されるが、必要に応じて手動管理

#### VRインタラクション最適化
1. **ハンドトラッキング**: OVRHandを使用したピンチジェスチャー
   - 既存のCarriableシステムを拡張
   - 不要な検出処理を避ける

2. **コントローラ操作**: OVRInputを使用
   - ボタン入力はGetDown/GetUpを使用（Getは避ける）
   - 連続的な入力処理は適切に間引き

3. **レイキャスト最適化**: インタラクション判定は必要最小限に
   - トリガーコライダーを使用（レイキャストより軽量）
   - 距離判定を追加して不要な処理を回避

## テスト・品質管理
- 新機能追加時はTestフォルダにテストコードを追加
- Quest実機ビルド前にエディタでの動作確認必須
- パフォーマンス計測機能の活用（Unity Profiler、OVR Metrics Tool）
- Quest実機での動作確認を必須とする（エディタでの動作確認のみでは不十分）

